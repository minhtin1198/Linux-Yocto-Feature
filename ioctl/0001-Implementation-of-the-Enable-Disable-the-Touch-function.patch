diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
index f382444dc2db..25afffef9e8f 100644
--- a/drivers/hid/hid-multitouch.c
+++ b/drivers/hid/hid-multitouch.c
@@ -40,6 +40,14 @@
 #include <linux/string.h>
 #include <linux/timer.h>
 
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/miscdevice.h>
+#include <linux/of_gpio.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
 
 MODULE_AUTHOR("Stephane Chatty <chatty@enac.fr>");
 MODULE_AUTHOR("Benjamin Tissoires <benjamin.tissoires@gmail.com>");
@@ -86,6 +94,10 @@ enum latency_mode {
 #define MT_IO_FLAGS_ACTIVE_SLOTS	1
 #define MT_IO_FLAGS_PENDING_SLOTS	2
 
+#define TOUCH_IOCTL_MAGIC 'T'
+#define TOUCH_IOCTL_ENABLE _IOW(TOUCH_IOCTL_MAGIC, 0, int)
+#define TOUCH_IOCTL_DISABLE _IOW(TOUCH_IOCTL_MAGIC, 1, int)
+
 static const bool mtrue = true;		/* default for true */
 static const bool mfalse;		/* default for false */
 static const __s32 mzero;		/* default for 0 */
@@ -159,6 +171,9 @@ struct mt_report_data {
 struct mt_device {
 	struct mt_class mtclass;	/* our mt device class */
 	struct timer_list release_timer;	/* to release sticky fingers */
+	
+	struct timer_list timeout_timer; /* to re-enable touch function */
+	
 	struct hid_device *hdev;	/* hid_device we're attached to */
 	unsigned long mt_io_flags;	/* mt flags (MT_IO_FLAGS_*) */
 	__u8 inputmode_value;	/* InputMode HID feature value */
@@ -170,6 +185,11 @@ struct mt_device {
 	struct list_head reports;
 };
 
+struct my_device_data {
+	struct hid_device *hdev;
+	struct mt_device *td;
+};
+
 static void mt_post_parse_default_settings(struct mt_device *td,
 					   struct mt_application *app);
 static void mt_post_parse(struct mt_device *td, struct mt_application *app);
@@ -224,6 +244,8 @@ static void mt_post_parse(struct mt_device *td, struct mt_application *app);
 #define MT_USB_DEVICE(v, p)	HID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH, v, p)
 #define MT_BT_DEVICE(v, p)	HID_DEVICE(BUS_BLUETOOTH, HID_GROUP_MULTITOUCH, v, p)
 
+static bool enable_touch_report = 1;
+
 /*
  * these device-dependent functions determine what slot corresponds
  * to a valid contact that was just read.
@@ -986,6 +1008,12 @@ static int mt_compute_timestamp(struct mt_application *app, __s32 value)
 static int mt_touch_event(struct hid_device *hid, struct hid_field *field,
 				struct hid_usage *usage, __s32 value)
 {
+	/*
+	if (!enable_touch_report) {
+		pr_info("Touch event ignored because touchscreen is disabled\n");
+		return 0;  // Ignore touch events if the touchscreen is disabled
+	}
+	*/
 	/* we will handle the hidinput part later, now remains hiddev */
 	if (hid->claimed & HID_CLAIMED_HIDDEV && hid->hiddev_hid_event)
 		hid->hiddev_hid_event(hid, field, usage, value);
@@ -1310,10 +1338,14 @@ static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 		struct hid_field *field, struct hid_usage *usage,
 		unsigned long **bit, int *max)
 {
+	if (!enable_touch_report) {
+		return 0;
+	}
+	
 	struct mt_device *td = hid_get_drvdata(hdev);
 	struct mt_application *application;
 	struct mt_report_data *rdata;
-
+	
 	rdata = mt_find_report_data(td, field->report);
 	if (!rdata) {
 		hid_err(hdev, "failed to allocate data for report\n");
@@ -1399,6 +1431,11 @@ static int mt_input_mapped(struct hid_device *hdev, struct hid_input *hi,
 static int mt_event(struct hid_device *hid, struct hid_field *field,
 				struct hid_usage *usage, __s32 value)
 {
+	if (!enable_touch_report) {
+		pr_info("mt_event is disabled\n");
+		return 0;
+	}
+	
 	struct mt_device *td = hid_get_drvdata(hid);
 	struct mt_report_data *rdata;
 
@@ -1417,7 +1454,7 @@ static void mt_report(struct hid_device *hid, struct hid_report *report)
 
 	if (!(hid->claimed & HID_CLAIMED_INPUT))
 		return;
-
+	
 	rdata = mt_find_report_data(td, report);
 	if (rdata && rdata->is_mt_collection)
 		return mt_touch_report(hid, rdata);
@@ -1698,12 +1735,90 @@ static void mt_expired_timeout(struct timer_list *t)
 	clear_bit(MT_IO_FLAGS_RUNNING, &td->mt_io_flags);
 }
 
+static void timeout_enabled_function (struct timer_list* t) {
+	struct mt_device *td = from_timer(td, t, timeout_timer);
+	// Enable touch function
+	pr_info("Timer Callback function!\n");
+	enable_touch_report = 1;
+	pr_info("Touch function was enabled, touch report value:%d.\n",enable_touch_report);
+}
+
+static int touch_open(struct inode *inode, struct file *file)
+{
+	struct hid_device *hdev;
+    struct my_device_data *data;
+	
+	hdev = container_of(inode->i_cdev, struct hid_device, dev);
+	data = kzalloc(sizeof(struct my_device_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->hdev = hdev;
+	data->td = hid_get_drvdata(hdev);
+	file->private_data = data;
+	return 0;
+}
+
+static int my_driver_release(struct inode *inode, struct file *file)
+{
+	struct my_device_data *data = file->private_data;
+
+	kfree(data);
+
+	return 0;
+}
+
+/* Implement touch function controler*/
+static long touch_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
+	struct my_device_data *data = file->private_data;
+    struct mt_device *td = data->td;
+	if (!td) {
+		pr_err("mt_device is null\n");
+		return -EINVAL;
+	}
+	
+	switch (cmd) {
+		case TOUCH_IOCTL_ENABLE:
+			// Enable touch function
+			enable_touch_report = 1;
+			pr_info("Touch function was enabled, touch report value:%d.\n",enable_touch_report);
+			break;
+		case TOUCH_IOCTL_DISABLE:
+			// Disable touch funtion
+			enable_touch_report = 0;
+			pr_info("Touch function was disabled, touch report value:%d.\n",enable_touch_report);
+			if (td->timeout_timer.function) {
+				pr_info("Set timeout\n");
+				mod_timer(&td->timeout_timer, jiffies + msecs_to_jiffies(10000));
+			} else {
+				pr_err("Timeout timer function is not set\n");
+				return -EINVAL;
+			}
+			break;
+		default:
+		return -ENOTTY; // Command not recognized
+	}
+	return 0;
+}
+
+static const struct file_operations touch_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = touch_ioctl,
+};
+
+static struct miscdevice touch_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "hid_multitouch",
+	.fops = &touch_fops,
+};
+
 static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
 	int ret, i;
+	int error;
 	struct mt_device *td;
 	const struct mt_class *mtclass = mt_classes; /* MT_CLS_DEFAULT */
-
+	
 	for (i = 0; mt_classes[i].name ; i++) {
 		if (id->driver_data == mt_classes[i].name) {
 			mtclass = &(mt_classes[i]);
@@ -1723,7 +1838,16 @@ static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 
 	INIT_LIST_HEAD(&td->applications);
 	INIT_LIST_HEAD(&td->reports);
-
+	
+	// Register the misc device
+	pr_info("Registing the misc device\n");
+	error = misc_register(&touch_misc_device);
+	if (error) {
+		dev_err(&hdev->dev, "Failed to register misc device: %d\n", error);
+		return error;
+	}
+	dev_info(&hdev->dev, "Misc device registered: /dev/%s\n", touch_misc_device.name);
+	
 	if (id->vendor == HID_ANY_ID && id->product == HID_ANY_ID)
 		td->serial_maybe = true;
 
@@ -1748,7 +1872,8 @@ static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	}
 
 	timer_setup(&td->release_timer, mt_expired_timeout, 0);
-
+	timer_setup(&td->timeout_timer, timeout_enabled_function, 0);
+	
 	ret = hid_parse(hdev);
 	if (ret != 0)
 		return ret;
@@ -1811,9 +1936,13 @@ static void mt_remove(struct hid_device *hdev)
 	struct mt_device *td = hid_get_drvdata(hdev);
 
 	del_timer_sync(&td->release_timer);
+	del_timer_sync(&td->timeout_timer);
 
 	sysfs_remove_group(&hdev->dev.kobj, &mt_attribute_group);
 	hid_hw_stop(hdev);
+	
+	/*Unregister the misc device*/
+	misc_deregister(&touch_misc_device);
 }
 
 /*
